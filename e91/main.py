from typing import Optional
import os
from fastapi import FastAPI
from pydantic import BaseModel
import requests
import json
import subprocess
from fastapi import File, UploadFile, FastAPI
from fastapi.encoders import jsonable_encoder
from fastapi.middleware.cors import CORSMiddleware

BASE_DIR  = os.path.dirname(os.path.abspath(__file__))

app = FastAPI()


origins = [
    "http://localhost",
    "http://localhost:8080/e91.html",
    "http://localhost:5500/e91.html",
    "http://127.0.0.1:5500/e91.html",
    "http://127.0.0.1:8000/e91.html"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class TokenData(BaseModel):
    n: int
    a_email: str
    b_email: str



def execute_code(source_code, language_id=71, stdin=None):
    URL = "http://18.219.240.65/submissions"

    querystring = {"base64_encoded": "false",
                   "wait": "true",
                   "fields": "stdout,time,memory,stderr,token,compile_output,message,status"}

    payload = {
        "language_id": language_id,
        "source_code": source_code,
        "stdin": stdin,
    }
    headers = {
        'content-type': "application/json",
    }

    response = requests.request("POST", URL, data=json.dumps(payload), headers=headers, params=querystring)
    return response.json()



@app.post("/")
async def index(item: TokenData):
    #print(item.bit, item.basis, item.a_email,item.b_email, item.isEve)
    source_codea = '#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n"""\nCreated on Sat Jan 29 20:10:24 2022\nE91: For the iQuHack\n@author: Lucas Arenstein\nrefs: Ekert, Artur K. "Quantum cryptography based on Bell\'s theorem" - 1991\n      https://github.com/kardashin/E91_protocol/blob/master/E91_tutorial/E91_tutorial.ipynb\n"""\n\n\n\nimport sys\n\nimport random\nimport math\nimport re #regexp module\n\n#Maybe I dont need all of this stuff\nfrom qiskit import QuantumCircuit, execute, Aer, QuantumRegister, ClassicalRegister\n\n\nfrom qiskit.visualization import plot_histogram\n\n\n# # # To Do # # #\n#ADD the api and connection stuff to quantuminspire\n\n\n#First qubit Alice, second qubit Bob\n#Classical Register (Cr): Alice = Cr[0], Bob = Cr[1], Eve = Cr[2,3]\n\n\ndef initial_setup():\n    qr = QuantumRegister(2)\n    cr = ClassicalRegister(4)\n    \n    ## Alice\'s measurement circuits\n    \n    # measure the spin projection of Alice\'s qubit onto the a_1 direction (X basis)\n    measureA1 = QuantumCircuit(2,4)\n    measureA1.h(0)\n    measureA1.measure(0,0)\n    \n    # measure the spin projection of Alice\'s qubit onto the a_2 direction (W basis)\n    measureA2 = QuantumCircuit(2,4)\n    measureA2.s(0)\n    measureA2.h(0)\n    measureA2.t(0)\n    measureA2.h(0)\n    measureA2.measure(0,0)\n    \n    # measure the spin projection of Alice\'s qubit onto the a_3 direction (standard Z basis)\n    measureA3 = QuantumCircuit(2,4)\n    measureA3.measure(0,0)\n    \n    ## Bob\'s measurement circuits\n    \n    # measure the spin projection of Bob\'s qubit onto the b_1 direction (W basis)\n    measureB1 = QuantumCircuit(2,4)\n    measureB1.s(1)\n    measureB1.h(1)\n    measureB1.t(1)\n    measureB1.h(1)\n    measureB1.measure(1,1)\n    \n    # measure the spin projection of Bob\'s qubit onto the b_2 direction (standard Z basis)\n    measureB2 = QuantumCircuit(2,4)\n    measureB2.measure(1,1)\n    \n    # measure the spin projection of Bob\'s qubit onto the b_3 direction (V basis)\n    measureB3 = QuantumCircuit(2,4)\n    measureB3.s(1)\n    measureB3.h(1)\n    measureB3.tdg(1)\n    measureB3.h(1)\n    measureB3.measure(1,1)\n    \n    ## Lists of measurement circuits\n    aliceMeasurements = [measureA1, measureA2, measureA3]\n    bobMeasurements = [measureB1, measureB2, measureB3]\n    \n    #Alice and Bob record the results of their measurements as bits of the strings a and a\'\n    abPatterns = [\n        re.compile(\'..00$\'), # search for the \'..00\' output (Alice obtained -1 and Bob obtained -1)\n        re.compile(\'..01$\'), # search for the \'..01\' output\n        re.compile(\'..10$\'), # search for the \'..10\' output (Alice obtained -1 and Bob obtained 1)\n        re.compile(\'..11$\')  # search for the \'..11\' output\n    ]\n\n    \n    return aliceMeasurements, bobMeasurements, abPatterns\n# # # # #\n\n# Supose Alice and Bob want to generate a secret key using N singlet states prepared by Charlie.\n\n\n#The participants must choose the directions onto which they will measure the spin projections of their qubits. \n#To do this, Alice and Bob create the strings b and b\' with randomly generated elements.\n\n# Now we combine Charlie\'s device and Alice\'s and Bob\'s detectors into one circuit (singlet + Alice\'s measurement + Bob\'s measurement).\n\n\n# Question: how many times do we have to run E92 to get a quantum key \n#with minimum lenght of n? \n\ndef run_circuits(numberOfSinglets, aliceMeasurements, bobMeasurements):\n    \n    aliceMeasurementChoices = [random.randint(1, 3) for i in range(numberOfSinglets)] # string b of Alice\n    bobMeasurementChoices = [random.randint(1, 3) for i in range(numberOfSinglets)] # string b\' of Bob\n\n    circuits = [] # the list in which the created circuits will be stored\n                  # circuitname,gen_circuit,circuitname,gen_circuit....\n                  # gen_circuit\n    circuitsNames = []    \n    \n    for i in range(numberOfSinglets):\n        # create the name of the i-th circuit depending on Alice\'s and Bob\'s measurement choices\n        circuitName = str(i) + \':A\' + str(aliceMeasurementChoices[i]) + \'_B\' + str(bobMeasurementChoices[i])\n        \n        # create the joint measurement circuit\n        # add Alice\'s and Bob\'s measurement circuits to the singlet state circuit\n        gen_circuit = QuantumCircuit(2, 4)\n    \n        gen_circuit.x(0)\n        gen_circuit.x(1)\n        gen_circuit.h(0)\n        gen_circuit.cx(0,1)\n        \n        gen_circuit.compose(aliceMeasurements[aliceMeasurementChoices[i]-1], inplace=True)\n        \n        gen_circuit.compose(bobMeasurements[bobMeasurementChoices[i]-1], inplace=True)\n        \n        circuitsNames.append(circuitName)\n        circuits.append(gen_circuit)\n\n        \'maybe QasmSimulator is more appropriate??\'\n    backend = Aer.get_backend(\'statevector_simulator\')\n    results = execute(circuits,backend, shots=1).result().get_counts()\n    \n    return aliceMeasurementChoices, bobMeasurementChoices, results\n\n#print(circuits[0])\n#0:A2_B3\n#print(circuits[2])\n#1:A2_B3\n#It tells us about the number of the singlet state received from Charlie, \n#and the measurements applied by Alice and Bob.\n#etc.\n#OLD\n\n\n\ndef build_key(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns):\n    \n    aliceResults = [] # Alice\'s results (string a)\n    bobResults = [] # Bob\'s results (string a\')\n    \n    for i in range(len(results)):\n    \n        #res = list(results.get_counts(circuitsNames[i]).keys())[0] # extract the key from the dict and transform it to str; execution result of the i-th circuit\n        \n        res = list(results[i])[0]\n        \n        if abPatterns[0].search(res): # check if the key is \'..00\' (if the measurement results are -1,-1)\n            aliceResults.append(-1) # Alice got the result -1 \n            bobResults.append(-1) # Bob got the result -1\n        if abPatterns[1].search(res):\n            aliceResults.append(1)\n            bobResults.append(-1)\n        if abPatterns[2].search(res): # check if the key is \'..10\' (if the measurement results are -1,1)\n            aliceResults.append(-1) # Alice got the result -1 \n            bobResults.append(1) # Bob got the result 1\n        if abPatterns[3].search(res): \n            aliceResults.append(1)\n            bobResults.append(1)\n            \n\n    aliceKey = [] # Alice\'s key string k\n    bobKey = [] # Bob\'s key string k\'\n\n\n    # comparing the stings with measurement choices\n    for i in range(len(results)):\n        # if Alice and Bob have measured the spin projections onto the a_2/b_1 or a_3/b_2 directions\n        if (aliceMeasurementChoices[i] == 2 and bobMeasurementChoices[i] == 1) or (aliceMeasurementChoices[i] == 3 and bobMeasurementChoices[i] == 2):\n            aliceKey.append(aliceResults[i]) # record the i-th result obtained by Alice as the bit of the secret key k\n            bobKey.append(- bobResults[i]) # record the multiplied by -1 i-th result obtained Bob as the bit of the secret key k\'\n            \n    keyLength = len(aliceKey) # length of the secret key\n\n\n    abKeyMismatches = 0 # number of mismatching bits in Alice\'s and Bob\'s keys\n    \n    for j in range(keyLength):\n        if aliceKey[j] != bobKey[j]:\n            abKeyMismatches += 1\n\n    return keyLength, abKeyMismatches, aliceKey\n\n\n\n\n\n# function that calculates CHSH correlation value\ndef chsh_corr(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns):\n    \n    # lists with the counts of measurement results\n    # each element represents the number of (-1,-1), (-1,1), (1,-1) and (1,1) results respectively\n    countA1B1 = [0, 0, 0, 0] # XW observable\n    countA1B3 = [0, 0, 0, 0] # XV observable\n    countA3B1 = [0, 0, 0, 0] # ZW observable\n    countA3B3 = [0, 0, 0, 0] # ZV observable\n\n    for i in range(len(results)):\n\n        res = list(results[i])[0]\n\n\n        # if the spins of the qubits of the i-th singlet were projected onto the a_1/b_1 directions\n        if (aliceMeasurementChoices[i] == 1 and bobMeasurementChoices[i] == 1):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA1B1[j] += 1\n\n        if (aliceMeasurementChoices[i] == 1 and bobMeasurementChoices[i] == 3):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA1B3[j] += 1\n\n        if (aliceMeasurementChoices[i] == 3 and bobMeasurementChoices[i] == 1):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA3B1[j] += 1\n                    \n        # if the spins of the qubits of the i-th singlet were projected onto the a_3/b_3 directions\n        if (aliceMeasurementChoices[i] == 3 and bobMeasurementChoices[i] == 3):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA3B3[j] += 1\n                    \n    # number of the results obtained from the measurements in a particular basis\n    total11 = sum(countA1B1)\n    total13 = sum(countA1B3)\n    total31 = sum(countA3B1)\n    total33 = sum(countA3B3)      \n                    \n    # expectation values of XW, XV, ZW and ZV observables (2)\n    expect11 = (countA1B1[0] - countA1B1[1] - countA1B1[2] + countA1B1[3])/total11 # -1/sqrt(2)\n    expect13 = (countA1B3[0] - countA1B3[1] - countA1B3[2] + countA1B3[3])/total13 # 1/sqrt(2)\n    expect31 = (countA3B1[0] - countA3B1[1] - countA3B1[2] + countA3B1[3])/total31 # -1/sqrt(2)\n    expect33 = (countA3B3[0] - countA3B3[1] - countA3B3[2] + countA3B3[3])/total33 # -1/sqrt(2) \n    \n    corr = expect11 - expect13 + expect31 + expect33 # calculate the CHSC correlation value (3)\n    \n    return corr\n\n\n\n#If C = -2*sqrt(2), then Alice and Bob can be sure that the states they had been receiving from Charlie were entangled indeed. \n#This fact tells the participants that there was no interference in the quantum channel.\n\n\n\n#n is the desired lenght of the Key Alice and Bob want to generate\n\ndef main(n):\n    \n    if n<10:\n        return print("Too few digits to distribute, try at least a 10")\n    \n    #Obtain this result after a series of simulations\n    lower_bound_singlets = 8*n\n    \n    aliceMeasurements, bobMeasurements, abPatterns = initial_setup()\n    \n    aliceMeasurementChoices, bobMeasurementChoices, results = run_circuits(lower_bound_singlets, aliceMeasurements, bobMeasurements)\n    \n    keyLength, abKeyMismatches, CommonKey = build_key(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns)\n    \n    corr = chsh_corr(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns)\n    \n    #Print Results:\n    print(\'CHSH correlation value: \' + str(round(corr, 3)))\n    print(\'Length of the key: \' + str(keyLength))\n    print(\'Number of mismatching bits: \' + str(abKeyMismatches) + \'\\n\')\n    \n    print(\'All the key\', CommonKey)\n    print(\'First n digits\', CommonKey[:n])\n    return \n\n\n#To run using a IDE\n#just run everything from line 1 to here  and call the function main\n#with your desired input, that is the lenght of the Key Alice and Bob want to create\n#> main(n)\n\nn_out ='+str(item.n)+'\n\n\n\nres = main(n_out)\n\n\nimport smtplib\nfrom email.message import EmailMessage\n\ngmail_user = \'alice.n.bob123@gmail.com\'\ngmail_password = \'EVEDONTHACKUS123!\'\n\nadam = 5\n\ninput_key = '+item.bit+'\n\nmsg = EmailMessage()\nmsg[\'Subject\'] = \'[IMPORTANT] YOUR QUANTUM KEY!\'\nmsg[\'From\'] = gmail_user\nmsg[\'To\'] = \'programmer3.7@outlook.com\'\n\nmsg.set_content(\'BB84\')\n\nmsg.add_alternative(f"<!DOCTYPE html><html><body><h3>Hi Alice! Here is your secret Information. Do not share with anyone!</h3> <p>Based on the size of the key {n_out} you want to share with bob, here is your secure key: {CommonKey[:n]} <br> Other information about the safety.</body> <br> Best Regards, <br> The Alice and Bob Team</html>", subtype=\'html\')\nmsg.set_content("Hello world")\n\nwith smtplib.SMTP_SSL(\'smtp.gmail.com\', 465) as smtp:\n    smtp.login(gmail_user, gmail_password)\n    smtp.send_message(msg)\ntry:\n    smtp_server = smtplib.SMTP_SSL(\'smtp.gmail.com\', 465)\n    smtp_server.ehlo()\n    smtp_server.login(gmail_user, gmail_password)\n    smtp_server.sendmail(sent_from, to, email_text)\n    smtp_server.close()\n    print ("Email sent successfully!")\nexcept Exception as ex:\n    print ("Something went wrong….",ex)\n'
    #source_code = '#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n"""\nCreated on Sat Jan 29 20:10:24 2022\nE91: For the iQuHack\n@author: Lucas Arenstein\nrefs: Ekert, Artur K. "Quantum cryptography based on Bell\'s theorem" - 1991\n      https://github.com/kardashin/E91_protocol/blob/master/E91_tutorial/E91_tutorial.ipynb\n"""\n\n\n\nimport sys\n\nimport random\nimport math\nimport re #regexp module\n\n#Maybe I dont need all of this stuff\nfrom qiskit import QuantumCircuit, execute, Aer, QuantumRegister, ClassicalRegister\n\n\nfrom qiskit.visualization import plot_histogram\n\n\n# # # To Do # # #\n#ADD the api and connection stuff to quantuminspire\n\n\n#First qubit Alice, second qubit Bob\n#Classical Register (Cr): Alice = Cr[0], Bob = Cr[1], Eve = Cr[2,3]\n\n\ndef initial_setup():\n    qr = QuantumRegister(2)\n    cr = ClassicalRegister(4)\n    \n    ## Alice\'s measurement circuits\n    \n    # measure the spin projection of Alice\'s qubit onto the a_1 direction (X basis)\n    measureA1 = QuantumCircuit(2,4)\n    measureA1.h(0)\n    measureA1.measure(0,0)\n    \n    # measure the spin projection of Alice\'s qubit onto the a_2 direction (W basis)\n    measureA2 = QuantumCircuit(2,4)\n    measureA2.s(0)\n    measureA2.h(0)\n    measureA2.t(0)\n    measureA2.h(0)\n    measureA2.measure(0,0)\n    \n    # measure the spin projection of Alice\'s qubit onto the a_3 direction (standard Z basis)\n    measureA3 = QuantumCircuit(2,4)\n    measureA3.measure(0,0)\n    \n    ## Bob\'s measurement circuits\n    \n    # measure the spin projection of Bob\'s qubit onto the b_1 direction (W basis)\n    measureB1 = QuantumCircuit(2,4)\n    measureB1.s(1)\n    measureB1.h(1)\n    measureB1.t(1)\n    measureB1.h(1)\n    measureB1.measure(1,1)\n    \n    # measure the spin projection of Bob\'s qubit onto the b_2 direction (standard Z basis)\n    measureB2 = QuantumCircuit(2,4)\n    measureB2.measure(1,1)\n    \n    # measure the spin projection of Bob\'s qubit onto the b_3 direction (V basis)\n    measureB3 = QuantumCircuit(2,4)\n    measureB3.s(1)\n    measureB3.h(1)\n    measureB3.tdg(1)\n    measureB3.h(1)\n    measureB3.measure(1,1)\n    \n    ## Lists of measurement circuits\n    aliceMeasurements = [measureA1, measureA2, measureA3]\n    bobMeasurements = [measureB1, measureB2, measureB3]\n    \n    #Alice and Bob record the results of their measurements as bits of the strings a and a\'\n    abPatterns = [\n        re.compile(\'..00$\'), # search for the \'..00\' output (Alice obtained -1 and Bob obtained -1)\n        re.compile(\'..01$\'), # search for the \'..01\' output\n        re.compile(\'..10$\'), # search for the \'..10\' output (Alice obtained -1 and Bob obtained 1)\n        re.compile(\'..11$\')  # search for the \'..11\' output\n    ]\n\n    \n    return aliceMeasurements, bobMeasurements, abPatterns\n# # # # #\n\n# Supose Alice and Bob want to generate a secret key using N singlet states prepared by Charlie.\n\n\n#The participants must choose the directions onto which they will measure the spin projections of their qubits. \n#To do this, Alice and Bob create the strings b and b\' with randomly generated elements.\n\n# Now we combine Charlie\'s device and Alice\'s and Bob\'s detectors into one circuit (singlet + Alice\'s measurement + Bob\'s measurement).\n\n\n# Question: how many times do we have to run E92 to get a quantum key \n#with minimum lenght of n? \n\ndef run_circuits(numberOfSinglets, aliceMeasurements, bobMeasurements):\n    \n    aliceMeasurementChoices = [random.randint(1, 3) for i in range(numberOfSinglets)] # string b of Alice\n    bobMeasurementChoices = [random.randint(1, 3) for i in range(numberOfSinglets)] # string b\' of Bob\n\n    circuits = [] # the list in which the created circuits will be stored\n                  # circuitname,gen_circuit,circuitname,gen_circuit....\n                  # gen_circuit\n    circuitsNames = []    \n    \n    for i in range(numberOfSinglets):\n        # create the name of the i-th circuit depending on Alice\'s and Bob\'s measurement choices\n        circuitName = str(i) + \':A\' + str(aliceMeasurementChoices[i]) + \'_B\' + str(bobMeasurementChoices[i])\n        \n        # create the joint measurement circuit\n        # add Alice\'s and Bob\'s measurement circuits to the singlet state circuit\n        gen_circuit = QuantumCircuit(2, 4)\n    \n        gen_circuit.x(0)\n        gen_circuit.x(1)\n        gen_circuit.h(0)\n        gen_circuit.cx(0,1)\n        \n        gen_circuit.compose(aliceMeasurements[aliceMeasurementChoices[i]-1], inplace=True)\n        \n        gen_circuit.compose(bobMeasurements[bobMeasurementChoices[i]-1], inplace=True)\n        \n        circuitsNames.append(circuitName)\n        circuits.append(gen_circuit)\n\n        \'maybe QasmSimulator is more appropriate??\'\n    backend = Aer.get_backend(\'statevector_simulator\')\n    results = execute(circuits,backend, shots=1).result().get_counts()\n    \n    return aliceMeasurementChoices, bobMeasurementChoices, results\n\n#print(circuits[0])\n#0:A2_B3\n#print(circuits[2])\n#1:A2_B3\n#It tells us about the number of the singlet state received from Charlie, \n#and the measurements applied by Alice and Bob.\n#etc.\n#OLD\n\n\n\ndef build_key(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns):\n    \n    aliceResults = [] # Alice\'s results (string a)\n    bobResults = [] # Bob\'s results (string a\')\n    \n    for i in range(len(results)):\n    \n        #res = list(results.get_counts(circuitsNames[i]).keys())[0] # extract the key from the dict and transform it to str; execution result of the i-th circuit\n        \n        res = list(results[i])[0]\n        \n        if abPatterns[0].search(res): # check if the key is \'..00\' (if the measurement results are -1,-1)\n            aliceResults.append(-1) # Alice got the result -1 \n            bobResults.append(-1) # Bob got the result -1\n        if abPatterns[1].search(res):\n            aliceResults.append(1)\n            bobResults.append(-1)\n        if abPatterns[2].search(res): # check if the key is \'..10\' (if the measurement results are -1,1)\n            aliceResults.append(-1) # Alice got the result -1 \n            bobResults.append(1) # Bob got the result 1\n        if abPatterns[3].search(res): \n            aliceResults.append(1)\n            bobResults.append(1)\n            \n\n    aliceKey = [] # Alice\'s key string k\n    bobKey = [] # Bob\'s key string k\'\n\n\n    # comparing the stings with measurement choices\n    for i in range(len(results)):\n        # if Alice and Bob have measured the spin projections onto the a_2/b_1 or a_3/b_2 directions\n        if (aliceMeasurementChoices[i] == 2 and bobMeasurementChoices[i] == 1) or (aliceMeasurementChoices[i] == 3 and bobMeasurementChoices[i] == 2):\n            aliceKey.append(aliceResults[i]) # record the i-th result obtained by Alice as the bit of the secret key k\n            bobKey.append(- bobResults[i]) # record the multiplied by -1 i-th result obtained Bob as the bit of the secret key k\'\n            \n    keyLength = len(aliceKey) # length of the secret key\n\n\n    abKeyMismatches = 0 # number of mismatching bits in Alice\'s and Bob\'s keys\n    \n    for j in range(keyLength):\n        if aliceKey[j] != bobKey[j]:\n            abKeyMismatches += 1\n\n    return keyLength, abKeyMismatches, aliceKey\n\n\n\n\n\n# function that calculates CHSH correlation value\ndef chsh_corr(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns):\n    \n    # lists with the counts of measurement results\n    # each element represents the number of (-1,-1), (-1,1), (1,-1) and (1,1) results respectively\n    countA1B1 = [0, 0, 0, 0] # XW observable\n    countA1B3 = [0, 0, 0, 0] # XV observable\n    countA3B1 = [0, 0, 0, 0] # ZW observable\n    countA3B3 = [0, 0, 0, 0] # ZV observable\n\n    for i in range(len(results)):\n\n        res = list(results[i])[0]\n\n\n        # if the spins of the qubits of the i-th singlet were projected onto the a_1/b_1 directions\n        if (aliceMeasurementChoices[i] == 1 and bobMeasurementChoices[i] == 1):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA1B1[j] += 1\n\n        if (aliceMeasurementChoices[i] == 1 and bobMeasurementChoices[i] == 3):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA1B3[j] += 1\n\n        if (aliceMeasurementChoices[i] == 3 and bobMeasurementChoices[i] == 1):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA3B1[j] += 1\n                    \n        # if the spins of the qubits of the i-th singlet were projected onto the a_3/b_3 directions\n        if (aliceMeasurementChoices[i] == 3 and bobMeasurementChoices[i] == 3):\n            for j in range(4):\n                if abPatterns[j].search(res):\n                    countA3B3[j] += 1\n                    \n    # number of the results obtained from the measurements in a particular basis\n    total11 = sum(countA1B1)\n    total13 = sum(countA1B3)\n    total31 = sum(countA3B1)\n    total33 = sum(countA3B3)      \n                    \n    # expectation values of XW, XV, ZW and ZV observables (2)\n    expect11 = (countA1B1[0] - countA1B1[1] - countA1B1[2] + countA1B1[3])/total11 # -1/sqrt(2)\n    expect13 = (countA1B3[0] - countA1B3[1] - countA1B3[2] + countA1B3[3])/total13 # 1/sqrt(2)\n    expect31 = (countA3B1[0] - countA3B1[1] - countA3B1[2] + countA3B1[3])/total31 # -1/sqrt(2)\n    expect33 = (countA3B3[0] - countA3B3[1] - countA3B3[2] + countA3B3[3])/total33 # -1/sqrt(2) \n    \n    corr = expect11 - expect13 + expect31 + expect33 # calculate the CHSC correlation value (3)\n    \n    return corr\n\n\n\n#If C = -2*sqrt(2), then Alice and Bob can be sure that the states they had been receiving from Charlie were entangled indeed. \n#This fact tells the participants that there was no interference in the quantum channel.\n\n\n\n#n is the desired lenght of the Key Alice and Bob want to generate\n\ndef main(n):\n    \n    if n<10:\n        return print("Too few digits to distribute, try at least a 10")\n    \n    #Obtain this result after a series of simulations\n    lower_bound_singlets = 8*n\n    \n    aliceMeasurements, bobMeasurements, abPatterns = initial_setup()\n    \n    aliceMeasurementChoices, bobMeasurementChoices, results = run_circuits(lower_bound_singlets, aliceMeasurements, bobMeasurements)\n    \n    keyLength, abKeyMismatches, CommonKey = build_key(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns)\n    \n    corr = chsh_corr(results, aliceMeasurementChoices, bobMeasurementChoices, abPatterns)\n    \n    #Print Results:\n    print(\'CHSH correlation value: \' + str(round(corr, 3)))\n    print(\'Length of the key: \' + str(keyLength))\n    print(\'Number of mismatching bits: \' + str(abKeyMismatches) + \'\\n\')\n    \n    print(\'All the key\', CommonKey)\n    print(\'First n digits\', CommonKey[:n])\n    return \n\n\n#To run using a IDE\n#just run everything from line 1 to here  and call the function main\n#with your desired input, that is the lenght of the Key Alice and Bob want to create\n#> main(n)\n\n\n\n\n\nmain(20)'

    
    a = execute_code(source_code)
    print(a)
    return a





